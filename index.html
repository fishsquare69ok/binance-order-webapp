#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import json
import logging
import telebot
from binance.client import Client
from binance.exceptions import BinanceAPIException
from telebot import types
from datetime import datetime

# è¨­å®šæ—¥èªŒ
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('bot.log', encoding='utf-8'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

class BinanceOrderBot:
    def __init__(self, config_file='binance_order_config.json'):
        """åˆå§‹åŒ–æ©Ÿå™¨äºº"""
        try:
            # è¼‰å…¥è¨­å®šæª”
            with open(config_file, 'r', encoding='utf-8') as f:
                self.config = json.load(f)
            
            # åˆå§‹åŒ– Telegram Bot
            self.bot = telebot.TeleBot(self.config['telegram_bot_token'])
            
            # åˆå§‹åŒ–è®Šæ•¸
            self.binance_client = None
            
            # è¨»å†Šè™•ç†å™¨
            self.register_handlers()
            
            logger.info("æ©Ÿå™¨äººåˆå§‹åŒ–å®Œæˆ")
            
        except Exception as e:
            logger.error(f"æ©Ÿå™¨äººåˆå§‹åŒ–å¤±æ•—: {e}")
            raise e

    def initialize_binance(self):
        """åˆå§‹åŒ–å¹£å®‰ API é€£æ¥"""
        try:
            self.binance_client = Client(
                api_key=self.config['binance_apikey'],
                api_secret=self.config['binance_apisecret'],
                testnet=self.config.get('binance_use_testnet', True)
            )
            
            # æ¸¬è©¦é€£æ¥
            account = self.binance_client.futures_account()
            logger.info("âœ… å¹£å®‰ API é€£æ¥æˆåŠŸ")
            return True
            
        except Exception as e:
            logger.error(f"âŒ å¹£å®‰ API é€£æ¥å¤±æ•—: {e}")
            return False

    def register_handlers(self):
        """è¨»å†Šæ‰€æœ‰ Telegram è¨Šæ¯è™•ç†å™¨"""
        
        @self.bot.message_handler(commands=['start'])
        def start_command(message):
            """å•Ÿå‹•æŒ‡ä»¤"""
            # æ”¹ç”¨ ReplyKeyboardMarkup
            markup = types.ReplyKeyboardMarkup(resize_keyboard=True, one_time_keyboard=True)
            
            # WebApp æŒ‰éˆ• - ä½¿ç”¨ KeyboardButton
            web_app = types.WebAppInfo(url="https://æ‚¨çš„GitHubç”¨æˆ¶å.github.io/binance-order-webapp/")
            markup.add(types.KeyboardButton(
                text="ğŸ“Š é–‹å•Ÿä¸‹å–®ä»‹é¢",
                web_app=web_app
            ))
            
            self.bot.send_message(
                message.chat.id,
                "ğŸš€ **å¹£å®‰ä¸‹å–®æ©Ÿå™¨äºº**\n\né»æ“Šä¸‹æ–¹æŒ‰éˆ•é–‹å•Ÿä¸‹å–®ä»‹é¢ï¼š",
                reply_markup=markup,
                parse_mode='Markdown'
            )

        @self.bot.message_handler(commands=['new_order'])
        def new_order_command(message):
            """ä¸‹å–®æŒ‡ä»¤"""
            # æ”¹ç”¨ ReplyKeyboardMarkup
            markup = types.ReplyKeyboardMarkup(resize_keyboard=True, one_time_keyboard=True)
            
            # WebApp æŒ‰éˆ•
            web_app = types.WebAppInfo(url="https://æ‚¨çš„GitHubç”¨æˆ¶å.github.io/binance-order-webapp/")
            markup.add(types.KeyboardButton(
                text="ğŸ“Š é–‹å•Ÿä¸‹å–®ä»‹é¢",
                web_app=web_app
            ))
            
            self.bot.send_message(
                message.chat.id,
                "ğŸ“Š **å»ºç«‹æ–°è¨‚å–®**\n\né»æ“Šä¸‹æ–¹æŒ‰éˆ•é–‹å•Ÿä¸‹å–®ä»‹é¢ï¼š",
                reply_markup=markup,
                parse_mode='Markdown'
            )

        # è™•ç† WebApp æ•¸æ“š
        @self.bot.message_handler(content_types=['web_app_data'])
        def handle_web_app_data(message):
            """è™•ç† WebApp å‚³å›çš„æ•¸æ“š"""
            try:
                data = json.loads(message.web_app_data.data)
                logger.info(f"æ”¶åˆ° WebApp æ•¸æ“š: {data}")
                
                # è§£æè¡¨å–®æ•¸æ“š
                symbol = data.get('symbol', 'BTCUSDT')
                if not symbol.endswith('USDT'):
                    symbol = symbol + 'USDT'
                
                direction = data.get('direction', 'BUY')
                quantity = float(data.get('quantity', 0))
                leverage = int(data.get('leverage', 10))
                order_type = data.get('order_type', 'MARKET')
                price = data.get('price', 0)
                stop_price = data.get('stop_price', 0)
                
                # å»ºç«‹è¨‚å–®æ•¸æ“š
                order_data = {
                    'symbol': symbol.upper(),
                    'side': 'BUY' if direction == 'åšå¤š' else 'SELL',
                    'order_type': order_type,
                    'quantity': quantity,
                    'leverage': leverage
                }
                
                if order_type == 'LIMIT' and price > 0:
                    order_data['price'] = float(price)
                
                if stop_price > 0:
                    order_data['stop_price'] = float(stop_price)
                
                # åŸ·è¡Œä¸‹å–®
                self.execute_order(message, order_data, data)
                
            except Exception as e:
                logger.error(f"WebApp æ•¸æ“šè™•ç†éŒ¯èª¤: {e}")
                self.bot.reply_to(message, f"âŒ æ•¸æ“šè™•ç†å¤±æ•—ï¼š{str(e)}")

    def execute_order(self, message, order_data, original_data):
        """åŸ·è¡Œè¨‚å–®"""
        try:
            # è¨­å®šæ§“æ¡¿
            self.binance_client.futures_change_leverage(
                symbol=order_data['symbol'],
                leverage=order_data['leverage']
            )
            
            # æº–å‚™è¨‚å–®åƒæ•¸
            order_params = {
                'symbol': order_data['symbol'],
                'side': order_data['side'],
                'type': order_data['order_type'],
                'quantity': order_data['quantity']
            }
            
            # é™åƒ¹å–®éœ€è¦åƒ¹æ ¼å’Œæ™‚æ•ˆ
            if order_data['order_type'] == 'LIMIT':
                order_params['price'] = order_data['price']
                order_params['timeInForce'] = 'GTC'
            
            # åŸ·è¡Œä¸»è¨‚å–®
            result = self.binance_client.futures_create_order(**order_params)
            
            # å¦‚æœæœ‰æ­¢æåƒ¹ï¼Œå»ºç«‹æ­¢æå–®
            stop_order_result = None
            if order_data.get('stop_price', 0) > 0:
                try:
                    stop_side = 'SELL' if order_data['side'] == 'BUY' else 'BUY'
                    stop_order_params = {
                        'symbol': order_data['symbol'],
                        'side': stop_side,
                        'type': 'STOP_MARKET',
                        'quantity': order_data['quantity'],
                        'stopPrice': order_data['stop_price']
                    }
                    stop_order_result = self.binance_client.futures_create_order(**stop_order_params)
                except Exception as stop_e:
                    logger.error(f"æ­¢æå–®å»ºç«‹å¤±æ•—: {stop_e}")
            
            # æˆåŠŸå›è¦†
            success_text = f"""
âœ… **ä¸‹å–®æˆåŠŸï¼**

ğŸ“‹ **ä¸»è¨‚å–®è™Ÿï¼š** {result['orderId']}
ğŸ“Š **äº¤æ˜“å°ï¼š** {order_data['symbol']}
ğŸ“ˆ **æ–¹å‘ï¼š** {original_data.get('direction', 'æœªçŸ¥')}
ğŸ’° **æ•¸é‡ï¼š** {order_data['quantity']}
âš™ï¸ **æ§“æ¡¿ï¼š** {order_data['leverage']}x
ğŸ• **æ™‚é–“ï¼š** {datetime.now().strftime('%H:%M:%S')}
            """
            
            if order_data['order_type'] == 'LIMIT':
                success_text += f"ğŸ¯ **åƒ¹æ ¼ï¼š** {order_data['price']} USDT\n"
            
            if stop_order_result:
                success_text += f"ğŸ›¡ï¸ **æ­¢æå–®è™Ÿï¼š** {stop_order_result['orderId']}\n"
                success_text += f"ğŸ”» **æ­¢æåƒ¹ï¼š** {order_data['stop_price']} USDT\n"
            elif order_data.get('stop_price', 0) > 0:
                success_text += f"âš ï¸ **æ­¢æå–®å»ºç«‹å¤±æ•—**\n"
            
            self.bot.reply_to(message, success_text, parse_mode='Markdown')
            logger.info(f"è¨‚å–®åŸ·è¡ŒæˆåŠŸ: {result['orderId']}")
            
        except BinanceAPIException as e:
            error_text = f"âŒ **ä¸‹å–®å¤±æ•—**\n\n**éŒ¯èª¤ï¼š** {e.message}"
            self.bot.reply_to(message, error_text, parse_mode='Markdown')
            logger.error(f"å¹£å®‰ API éŒ¯èª¤: {e}")
            
        except Exception as e:
            error_text = f"âŒ **ä¸‹å–®å¤±æ•—**\n\n**éŒ¯èª¤ï¼š** {str(e)}"
            self.bot.reply_to(message, error_text, parse_mode='Markdown')
            logger.error(f"ä¸‹å–®åŸ·è¡ŒéŒ¯èª¤: {e}")

    def run(self):
        """å•Ÿå‹•æ©Ÿå™¨äºº"""
        try:
            if not self.initialize_binance():
                logger.error("âŒ ç„¡æ³•é€£æ¥åˆ°å¹£å®‰ APIï¼Œæ©Ÿå™¨äººå•Ÿå‹•å¤±æ•—")
                return False
            
            logger.info("ğŸš€ æ©Ÿå™¨äººå•Ÿå‹•æˆåŠŸï¼Œé–‹å§‹æ¥æ”¶è¨Šæ¯...")
            print("ğŸš€ æ©Ÿå™¨äººå·²å•Ÿå‹•ï¼Œå¯ä»¥é–‹å§‹ä½¿ç”¨ï¼")
            print("ğŸ“± è«‹åˆ° Telegram ç™¼é€ /start é–‹å§‹ä½¿ç”¨")
            
            self.bot.infinity_polling(none_stop=True, interval=0)
            
        except Exception as e:
            logger.error(f"æ©Ÿå™¨äººé‹è¡ŒéŒ¯èª¤: {e}")
            print(f"âŒ æ©Ÿå™¨äººé‹è¡Œå¤±æ•—: {e}")
            return False

if __name__ == "__main__":
    try:
        bot = BinanceOrderBot()
        bot.run()
    except KeyboardInterrupt:
        print("\nğŸ‘‹ æ©Ÿå™¨äººå·²åœæ­¢")
    except Exception as e:
        print(f"âŒ å•Ÿå‹•å¤±æ•—: {e}")
