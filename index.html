#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import json
import logging
import telebot
from binance.client import Client
from binance.exceptions import BinanceAPIException
from telebot import types
from datetime import datetime

# 設定日誌
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('bot.log', encoding='utf-8'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

class BinanceOrderBot:
    def __init__(self, config_file='binance_order_config.json'):
        """初始化機器人"""
        try:
            # 載入設定檔
            with open(config_file, 'r', encoding='utf-8') as f:
                self.config = json.load(f)
            
            # 初始化 Telegram Bot
            self.bot = telebot.TeleBot(self.config['telegram_bot_token'])
            
            # 初始化變數
            self.binance_client = None
            
            # 註冊處理器
            self.register_handlers()
            
            logger.info("機器人初始化完成")
            
        except Exception as e:
            logger.error(f"機器人初始化失敗: {e}")
            raise e

    def initialize_binance(self):
        """初始化幣安 API 連接"""
        try:
            self.binance_client = Client(
                api_key=self.config['binance_apikey'],
                api_secret=self.config['binance_apisecret'],
                testnet=self.config.get('binance_use_testnet', True)
            )
            
            # 測試連接
            account = self.binance_client.futures_account()
            logger.info("✅ 幣安 API 連接成功")
            return True
            
        except Exception as e:
            logger.error(f"❌ 幣安 API 連接失敗: {e}")
            return False

    def register_handlers(self):
        """註冊所有 Telegram 訊息處理器"""
        
        @self.bot.message_handler(commands=['start'])
        def start_command(message):
            """啟動指令"""
            # 改用 ReplyKeyboardMarkup
            markup = types.ReplyKeyboardMarkup(resize_keyboard=True, one_time_keyboard=True)
            
            # WebApp 按鈕 - 使用 KeyboardButton
            web_app = types.WebAppInfo(url="https://您的GitHub用戶名.github.io/binance-order-webapp/")
            markup.add(types.KeyboardButton(
                text="📊 開啟下單介面",
                web_app=web_app
            ))
            
            self.bot.send_message(
                message.chat.id,
                "🚀 **幣安下單機器人**\n\n點擊下方按鈕開啟下單介面：",
                reply_markup=markup,
                parse_mode='Markdown'
            )

        @self.bot.message_handler(commands=['new_order'])
        def new_order_command(message):
            """下單指令"""
            # 改用 ReplyKeyboardMarkup
            markup = types.ReplyKeyboardMarkup(resize_keyboard=True, one_time_keyboard=True)
            
            # WebApp 按鈕
            web_app = types.WebAppInfo(url="https://您的GitHub用戶名.github.io/binance-order-webapp/")
            markup.add(types.KeyboardButton(
                text="📊 開啟下單介面",
                web_app=web_app
            ))
            
            self.bot.send_message(
                message.chat.id,
                "📊 **建立新訂單**\n\n點擊下方按鈕開啟下單介面：",
                reply_markup=markup,
                parse_mode='Markdown'
            )

        # 處理 WebApp 數據
        @self.bot.message_handler(content_types=['web_app_data'])
        def handle_web_app_data(message):
            """處理 WebApp 傳回的數據"""
            try:
                data = json.loads(message.web_app_data.data)
                logger.info(f"收到 WebApp 數據: {data}")
                
                # 解析表單數據
                symbol = data.get('symbol', 'BTCUSDT')
                if not symbol.endswith('USDT'):
                    symbol = symbol + 'USDT'
                
                direction = data.get('direction', 'BUY')
                quantity = float(data.get('quantity', 0))
                leverage = int(data.get('leverage', 10))
                order_type = data.get('order_type', 'MARKET')
                price = data.get('price', 0)
                stop_price = data.get('stop_price', 0)
                
                # 建立訂單數據
                order_data = {
                    'symbol': symbol.upper(),
                    'side': 'BUY' if direction == '做多' else 'SELL',
                    'order_type': order_type,
                    'quantity': quantity,
                    'leverage': leverage
                }
                
                if order_type == 'LIMIT' and price > 0:
                    order_data['price'] = float(price)
                
                if stop_price > 0:
                    order_data['stop_price'] = float(stop_price)
                
                # 執行下單
                self.execute_order(message, order_data, data)
                
            except Exception as e:
                logger.error(f"WebApp 數據處理錯誤: {e}")
                self.bot.reply_to(message, f"❌ 數據處理失敗：{str(e)}")

    def execute_order(self, message, order_data, original_data):
        """執行訂單"""
        try:
            # 設定槓桿
            self.binance_client.futures_change_leverage(
                symbol=order_data['symbol'],
                leverage=order_data['leverage']
            )
            
            # 準備訂單參數
            order_params = {
                'symbol': order_data['symbol'],
                'side': order_data['side'],
                'type': order_data['order_type'],
                'quantity': order_data['quantity']
            }
            
            # 限價單需要價格和時效
            if order_data['order_type'] == 'LIMIT':
                order_params['price'] = order_data['price']
                order_params['timeInForce'] = 'GTC'
            
            # 執行主訂單
            result = self.binance_client.futures_create_order(**order_params)
            
            # 如果有止損價，建立止損單
            stop_order_result = None
            if order_data.get('stop_price', 0) > 0:
                try:
                    stop_side = 'SELL' if order_data['side'] == 'BUY' else 'BUY'
                    stop_order_params = {
                        'symbol': order_data['symbol'],
                        'side': stop_side,
                        'type': 'STOP_MARKET',
                        'quantity': order_data['quantity'],
                        'stopPrice': order_data['stop_price']
                    }
                    stop_order_result = self.binance_client.futures_create_order(**stop_order_params)
                except Exception as stop_e:
                    logger.error(f"止損單建立失敗: {stop_e}")
            
            # 成功回覆
            success_text = f"""
✅ **下單成功！**

📋 **主訂單號：** {result['orderId']}
📊 **交易對：** {order_data['symbol']}
📈 **方向：** {original_data.get('direction', '未知')}
💰 **數量：** {order_data['quantity']}
⚙️ **槓桿：** {order_data['leverage']}x
🕐 **時間：** {datetime.now().strftime('%H:%M:%S')}
            """
            
            if order_data['order_type'] == 'LIMIT':
                success_text += f"🎯 **價格：** {order_data['price']} USDT\n"
            
            if stop_order_result:
                success_text += f"🛡️ **止損單號：** {stop_order_result['orderId']}\n"
                success_text += f"🔻 **止損價：** {order_data['stop_price']} USDT\n"
            elif order_data.get('stop_price', 0) > 0:
                success_text += f"⚠️ **止損單建立失敗**\n"
            
            self.bot.reply_to(message, success_text, parse_mode='Markdown')
            logger.info(f"訂單執行成功: {result['orderId']}")
            
        except BinanceAPIException as e:
            error_text = f"❌ **下單失敗**\n\n**錯誤：** {e.message}"
            self.bot.reply_to(message, error_text, parse_mode='Markdown')
            logger.error(f"幣安 API 錯誤: {e}")
            
        except Exception as e:
            error_text = f"❌ **下單失敗**\n\n**錯誤：** {str(e)}"
            self.bot.reply_to(message, error_text, parse_mode='Markdown')
            logger.error(f"下單執行錯誤: {e}")

    def run(self):
        """啟動機器人"""
        try:
            if not self.initialize_binance():
                logger.error("❌ 無法連接到幣安 API，機器人啟動失敗")
                return False
            
            logger.info("🚀 機器人啟動成功，開始接收訊息...")
            print("🚀 機器人已啟動，可以開始使用！")
            print("📱 請到 Telegram 發送 /start 開始使用")
            
            self.bot.infinity_polling(none_stop=True, interval=0)
            
        except Exception as e:
            logger.error(f"機器人運行錯誤: {e}")
            print(f"❌ 機器人運行失敗: {e}")
            return False

if __name__ == "__main__":
    try:
        bot = BinanceOrderBot()
        bot.run()
    except KeyboardInterrupt:
        print("\n👋 機器人已停止")
    except Exception as e:
        print(f"❌ 啟動失敗: {e}")
